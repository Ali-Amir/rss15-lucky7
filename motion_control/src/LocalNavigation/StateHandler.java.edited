package LocalNavigation;

import org.ros.message.rss_msgs.BumpMsg;
import org.ros.message.rss_msgs.MotionMsg;
import org.ros.message.rss_msgs.OdometryMsg;
import org.ros.message.rss_msgs.SonarMsg;
import org.ros.node.topic.Publisher;
import org.ros.node.Node;

enum State {
  STOP_ON_BUMP, ALIGN_ON_BUMP, ALIGNING, ALIGNED, ALIGNED_AND_ROTATING,
  ALIGNED_AND_ROTATED, BACKING_UP, FINDING_WALL, TRACKING_WALL, WALL_ENDED,
  SENSING_WALL, WALL_SENSED, DONE
}

enum SonarState {
  NOT_OBSERVING, OBSERVING, TRACKING
}

public class StateHandler {

  State state = State.ALIGN_ON_BUMP;
  MotionCommander motionCommander;
  WallModel wallModel;

  double desired_dist;
  double desired_theta;

  double robot_x;
  double robot_y;
  double robot_theta;
  double paramA;
  double paramB;
  double paramC;

  double turned = 0;
  double prevTheta;
  double newTheta;

  SonarState sonarState = SonarState.NOT_OBSERVING;

  double alpha = .7;

  boolean[] clearedWallSonars = new boolean[2];
  boolean[] seenWallSonars = new boolean[2];
  double perc = .20;



  double trans_err;
  double rotate_err;

  StateHandler(State initState, Node initNode) {
    state = initState;
    motionCommander = new MotionCommander(initNode);
    wallModel = new WallModel(initNode);
  }

  State getState() {
    return state;
  }

  void setState(State newState) {
    if (newState != state) {
      System.out.println("Changing state from " + state.toString() +
                         " to " + newState.toString());
      state = newState;
    }
  }

  void handleOdometryMsg(OdometryMsg msg) {
    robot_x = msg.x;
    robot_y = msg.y;
    robot_theta = msg.theta;
    motionCommander.updateState(msg.x, msg.y, msg.theta);
    motionCommander.step();

    if (this.getState() == State.ALIGN_ON_BUMP){
<<<<<<< .mine
      if (turned>Math.PI*2-.3){
        this.setState(State.DONE);
        MotionCommand[] comm = {new StopCommand()};
        motionCommander.command(comm);
      } else {
        MotionCommand[] comms = {new PersistentCommand(0.25, Math.PI/20)};
        motionCommander.command(comms);
      }
=======
      MotionCommand[] comms = {new PersistentCommand(0.15, Math.PI/20   )};
      motionCommander.command(comms);
>>>>>>> .r207
    }

    if (this.getState() == State.ALIGNED) {
      
      newTheta = motionCommander.robot_theta - Math.PI/2;
      if (newTheta<0){
        newTheta+=Math.PI*2;
      }
      turned+= newTheta-prevTheta;
      
      if (turned>Math.PI*2-.3){
        this.setState(State.DONE);
        MotionCommand[] comm = {new StopCommand()};
        motionCommander.command(comm);
      } else {

        this.setState(State.ALIGNED_AND_ROTATING);
        MotionCommand[] comms = {new TranslateCommand(-0.4),
                                 new StopCommand(),
                                 new RotateCommand(-Math.PI/2.0),
                                 new StopCommand()};
        motionCommander.command(comms);
      }
    }

    if (this.getState() == State.ALIGNED_AND_ROTATING) {
      if (motionCommander.isDone()) {
        this.setState(State.ALIGNED_AND_ROTATED);
      }
    }

    if (this.getState() == State.ALIGNED_AND_ROTATED) {
      this.setState(State.SENSING_WALL);
      sonarState = SonarState.OBSERVING;
      desired_theta = motionCommander.robot_theta;
      wallModel.resetModel();
    }
    if (this.getState() == State.SENSING_WALL) {
      if (wallModel.isWallStable()) {
        this.setState(State.WALL_SENSED);
      }
    }
    if (this.getState() == State.WALL_SENSED) {
      this.setState(State.BACKING_UP);
      clearedWallSonars[0] = false;
      clearedWallSonars[1] = false;
      seenWallSonars[0] = true;
      seenWallSonars[1] = true;
      sonarState = SonarState.TRACKING;
    }

    if (this.getState() == State.WALL_ENDED) {
      this.setState(State.ALIGN_ON_BUMP);
      sonarState = SonarState.NOT_OBSERVING;
      prevTheta = robot_theta;
    }
  }

  void handleSonarMsg(SonarMsg msg, boolean obstacle) {
    int sonar = msg.isFront ? 1 : 0;
    updateWallSonars(msg, sonar);

    double p[] = LocalNavigation.getCoordsOffset(
        robot_x, robot_y, robot_theta,
        LocalNavigation.SONAR_REL_X[sonar],
        LocalNavigation.SONAR_REL_Y[sonar]+msg.range);
    if (obstacle && (this.getState() == State.SENSING_WALL ||
         (wallModel.isPartOfWall(msg.range, p[0], p[1]) &&
          (this.getState() == State.BACKING_UP ||
           this.getState() == State.TRACKING_WALL)))) {
//      isWall(msg.range)) {
      System.out.println(p[0] + "  " + p[1]);
      wallModel.addObservation(p[0], p[1]);
    }

    if (this.getState() == State.BACKING_UP) {
      System.out.println("///WALL LOGIC///");
      System.out.println(clearedWallSonars[0]);
      System.out.println(clearedWallSonars[1]);
      System.out.println(seenWallSonars[0]);
      System.out.println(seenWallSonars[1]);
      if (!clearedWallSonars[0] || !clearedWallSonars[1]) {
        MotionCommand[] comm = getWallTrackingComms(false);
        motionCommander.command(comm);
      } else {
        MotionCommand[] comm = {new StopCommand()};
        motionCommander.command(comm);
        this.setState(State.FINDING_WALL);
      }
    }

    if (this.getState() == State.FINDING_WALL){
      if (wallModel.isPartOfWall(msg.range, p[0], p[1])) {
        this.setState(State.TRACKING_WALL);
        
        desired_theta = motionCommander.robot_theta;
//        wallModel.resetModel();
        clearedWallSonars[0] = false;
        clearedWallSonars[1] = false;
        seenWallSonars[0] = false;
        seenWallSonars[1] = false;
      } else {
        MotionCommand[] comm = {new PersistentCommand(0.2, 0.0)};
        motionCommander.command(comm);
      }
    }

    if (this.getState() == State.TRACKING_WALL) {
      System.out.println("///WALL LOGIC///");
      System.out.println(clearedWallSonars[0]);
      System.out.println(clearedWallSonars[1]);
      System.out.println(seenWallSonars[0]);
      System.out.println(seenWallSonars[1]);
      System.out.println(trans_err);
      if (clearedWallSonars[0] && clearedWallSonars[1]){
        this.setState(State.WALL_ENDED);
        wallModel.drawWall();
        sonarState = SonarState.OBSERVING;
        MotionCommand[] comm = {new StopCommand()};
        motionCommander.command(comm);
      } else {
        MotionCommand[] comm = getWallTrackingComms(true);
        motionCommander.command(comm);
      }
    }

    
  }

  void handleBumpMsg(BumpMsg msg) {
    if (this.getState() == State.ALIGN_ON_BUMP) {
      if (msg.left || msg.right) {
        this.setState(State.ALIGNING);
      } else {
        // Tell it to keep moving forward. First parameter is translational
        // velocity. Second parameter is rotational velocity.
        MotionCommand[] comm = {new PersistentCommand(0.2, 0.0)};
        motionCommander.command(comm);
      }
    }

    if (this.getState() == State.ALIGNING){
      if (msg.left && msg.right){
        this.setState(State.ALIGNED);
      } else if (msg.left) {
        // Tell it to keep rotating left. First parameter is translational
        // velocity. Second parameter is rotational velocity.
        MotionCommand[] comm = {new PersistentCommand(0.0, Math.PI/100.0)};
        motionCommander.command(comm);
      } else if (msg.right) {
        // Tell it to keep rotating right. First parameter is translational
        // velocity. Second parameter is rotational velocity.
        MotionCommand[] comm = {new PersistentCommand(0.0, -Math.PI/100.0)};
        motionCommander.command(comm);
      } else {
        // Tell it to keep moving forward. First parameter is translational
        // velocity. Second parameter is rotational velocity.
        MotionCommand[] comm = {new PersistentCommand(0.05, 0.0)};
        motionCommander.command(comm);
      }
    }

    if (state == State.ALIGNED) {
      // Command it to stop.
      MotionCommand[] comm = {new StopCommand()};
      motionCommander.command(comm);
    }

    if (state == State.STOP_ON_BUMP && (msg.left || msg.right)){
      // Command it to stop if we hit on something.
      MotionCommand[] comm = {new StopCommand()};
      motionCommander.command(comm);
    }
  }

  public boolean isWall(double range){
    if (sonarState == SonarState.TRACKING){
      if (withinPercent(range, desired_dist, perc)){
        return true;
      } else {
        return false;
      }
    } else if (sonarState == SonarState.OBSERVING){
      return true;
    } else {
      return false;
    }
  }

  void updateWallSonars(SonarMsg msg, int sonar){
    double p[] = LocalNavigation.getCoordsOffset(
        robot_x, robot_y, robot_theta,
        LocalNavigation.SONAR_REL_X[sonar],
        LocalNavigation.SONAR_REL_Y[sonar]+msg.range);
    if (wallModel.isPartOfWall(msg.range, p[0], p[1])) {
      seenWallSonars[sonar] = true;
    }
    

    if (!clearedWallSonars[sonar]){
      if (seenWallSonars[sonar]){
        if (!wallModel.isPartOfWall(msg.range, p[0], p[1])) {
          System.out.println("///TEST//");
          System.out.println("Sonar: "+sonar);
          System.out.println("Range: "+ msg.range);
          System.out.println("prevRange: "+ desired_dist);
          clearedWallSonars[sonar] = true;
        }
      }
    }
  }

  private boolean withinPercent(double value, double standard, double percent) {
    standard = Math.abs(standard);
    value = Math.abs(value);
    return (value > standard*(1-percent) && value < standard*(1+percent));
  }

  private double calcPerpDistance(){
    return Math.abs(paramA*motionCommander.robot_x + paramB*motionCommander.robot_y + paramC);
  }

  private void calcTransError(){
    trans_err = calcPerpDistance() - desired_dist;
  }

  private void calcRotateError(){
    rotate_err = motionCommander.robot_theta - desired_theta;
  }

  private MotionCommand[] getWallTrackingComms(boolean forward){
    calcTransError();
    calcRotateError();
    double rotate_offset = 0;
    if (trans_err>.05){
      rotate_offset+=Math.PI/100;
    } else if (trans_err<-.05){
      rotate_offset-=Math.PI/100;
    } 

    if (forward){
      
      MotionCommand[] comm = {new PersistentCommand(0.2, 0.0)};//-rotate_err+rotate_offset)};
      return comm;
    } else {
      // System.out.println("//////DIAGNOSTICS///////");
      // System.out.println("Desired Theta: " + desired_theta);
      // System.out.println("Current Theta: " + motionCommander.robot_theta);
      // System.out.println("Error : " + rotate_err);
      // System.out.println("Offset : " + rotate_offset);

      // System.out.println("Desired Dist : " + desired_dist);
      // System.out.println("Trans_Err : " + trans_err);
      MotionCommand[] comm = {new PersistentCommand(-0.2, 0.0)};//-rotate_err-rotate_offset)};
      return comm;
    }
    
  }

}


